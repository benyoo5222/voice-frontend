{"ast":null,"code":"var _jsxFileName = \"/Users/benyoo/Desktop/voice-frontend/src/App.js\";\nimport React from 'react';\nimport logo from \"./logo.svg\";\nimport './App.css';\nimport crypto from 'crypto';\nimport v4 from './lib/aws-signature-v4';\nimport audioUtils from './lib/audioUtils';\nimport mic from 'microphone-stream'; // import marshaller from '@aws-sdk/eventstream-marshaller';\n// import util_utf8_node from '@aws-sdk/util-utf8-node';\n\nconst marshaller = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\n\n\nconst util_utf8_node = require(\"@aws-sdk/util-utf8-node\");\n\nconst BSON = require('bson');\n\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\nconst context = new AudioContext(); // const key = process.env.KEY;\n// const secret_key = process.env.SECRET_KEY;\n// const session_token = process.env.SESSION_TOKEN;\n// const region = process.env.REGION;\n// const language = process.env.LANGUAGE;\n// const sampleRate = process.env.SAMPLE_RATE;\n\nlet socket;\nlet micStream;\nlet inputSampleRate;\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8);\nconst websocket = new WebSocket('ws://localhost:8000'); //put url\n\nwebsocket.binaryType = \"arraybuffer\";\n\nwebsocket.onopen = () => {\n  console.log(\"Connected\");\n};\n\nwebsocket.onerror = () => {\n  console.log(\"Error!!!!!!!!!\");\n};\n\nwebsocket.onmessage = message => {\n  console.log(\"MESSAGE\", message);\n};\n\nconst getAudioEventMessage = buffer => {\n  // wrap the audio data in a JSON envelope\n  return {\n    headers: {\n      ':message-type': {\n        type: 'string',\n        value: 'event'\n      },\n      ':event-type': {\n        type: 'string',\n        value: 'AudioEvent'\n      }\n    },\n    body: buffer\n  };\n};\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n  let raw = mic.toRaw(audioChunk);\n  console.log(\"RAW\", raw);\n  if (raw == null) return; // downsample and convert the raw audio bytes to PCM\n\n  console.log(\"inputSamplerate\", inputSampleRate);\n  let downsampledBuffer = audioUtils.downsampleBuffer(raw, inputSampleRate, 16000);\n  console.log(\"downsampled\", downsampledBuffer);\n  let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer); // add the right JSON headers and structure to the message\n\n  let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer)); //convert the JSON object + headers into a binary event stream message\n\n  let binary = eventStreamMarshaller.marshall(audioEventMessage);\n  return binary;\n}\n\n;\n\nvar downsampleBuffer = function (buffer, sampleRate, outSampleRate) {\n  if (outSampleRate == sampleRate) {\n    return buffer;\n  }\n\n  if (outSampleRate > sampleRate) {\n    throw \"downsampling rate show be smaller than original sample rate\";\n  }\n\n  var sampleRateRatio = sampleRate / outSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Int16Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0,\n        count = 0;\n\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n\n    result[offsetResult] = Math.min(1, accum / count) * 0x7FFF;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n\n  return result; //return result.buffer;\n};\n\nconst handleListen = () => {\n  navigator.mediaDevices.getUserMedia({\n    audio: true\n  }).then(stream => {\n    console.log(\"STREAm!!!\", stream);\n    let processor = context.createScriptProcessor(2048, 1, 1);\n    processor.connect(context.destination);\n    context.resume();\n    let input = context.createMediaStreamSource(stream);\n    input.connect(processor);\n\n    processor.onaudioprocess = function (e) {\n      var left = e.inputBuffer.getChannelData(0); // var left16 = convertFloat32ToInt16(left); // old 32 to 16 function\n\n      var left16 = downsampleBuffer(left, 44100, 16000);\n      console.log(\"Buffer\", left16); //websocket.send(left16);\n\n      websocket.send(JSON.stringify({\n        connectionID: 3333,\n        audio: Array.from(left16)\n      })); //websocket.send(BSON.serialize({connectionID: 3333, audio: left16}));\n    }; // micStream = new mic();\n    // micStream.on(\"format\", function(data) {\n    //     inputSampleRate = data.sampleRate;\n    // });\n    // micStream.setStream(stream);\n    // // const websocket = new WebSocket('ws://localhost:8000'); //put url\n    // // websocket.binaryType = \"arraybuffer\";\n    // micStream.on('data', function(rawAudioChunk) {\n    //   // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n    //   console.log(\"DATA\", rawAudioChunk);\n    //   //let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //   let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //   console.log(\"Binary\", binary);\n    //   //websocket.emit('startGoogleCloudStream', '');\n    //   websocket.send(audioUtils.downsampleBuffer(rawAudioChunk, inputSampleRate, 16000));\n    //   //websocket.send(BSON.serialize({connectionID: 3333, audio: binary}));\n    //   //websocket.emit(\"binaryData\". BSON.serialize({connectionID: 3333, audio: binary}))\n    //   //websocket.send(binary);\n    //   // if (socket.readyState === socket.OPEN)\n    //   //     socket.send(binary);\n    // })    \n    // websocket.onopen = () => {\n    //   console.log(\"Connected\");\n    //   micStream.on('data', function(rawAudioChunk) {\n    //     // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n    //     console.log(\"DATA\", rawAudioChunk);\n    //     //let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //     let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //     console.log(\"Binary\", binary);\n    //     websocket.send(binary);\n    //     // if (socket.readyState === socket.OPEN)\n    //     //     socket.send(binary);\n    //   })    \n    // };\n\n\n    websocket.onerror = () => {\n      console.log(\"Error!!!!!!!!!\");\n    };\n\n    websocket.onmessage = message => {\n      console.log(\"MESSAGE\", message);\n    };\n  }).catch(err => {\n    console.log(\"error\", err);\n  });\n};\n\nfunction App() {\n  handleListen();\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 197,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"header\", {\n    className: \"App-header\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 198,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"img\", {\n    src: logo,\n    className: \"App-logo\",\n    alt: \"logo\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 199,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 9\n    }\n  }, \"Edit \", /*#__PURE__*/React.createElement(\"code\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 16\n    }\n  }, \"src/App.js\"), \" and save to reload.\"), /*#__PURE__*/React.createElement(\"a\", {\n    className: \"App-link\",\n    href: \"https://reactjs.org\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 203,\n      columnNumber: 9\n    }\n  }, \"Learn React\")));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/benyoo/Desktop/voice-frontend/src/App.js"],"names":["React","crypto","v4","audioUtils","mic","marshaller","require","util_utf8_node","BSON","AudioContext","window","webkitAudioContext","context","socket","micStream","inputSampleRate","eventStreamMarshaller","EventStreamMarshaller","toUtf8","fromUtf8","websocket","WebSocket","binaryType","onopen","console","log","onerror","onmessage","message","getAudioEventMessage","buffer","headers","type","value","body","convertAudioToBinaryMessage","audioChunk","raw","toRaw","downsampledBuffer","downsampleBuffer","pcmEncodedBuffer","pcmEncode","audioEventMessage","Buffer","from","binary","marshall","sampleRate","outSampleRate","sampleRateRatio","newLength","Math","round","length","result","Int16Array","offsetResult","offsetBuffer","nextOffsetBuffer","accum","count","i","min","handleListen","navigator","mediaDevices","getUserMedia","audio","then","stream","processor","createScriptProcessor","connect","destination","resume","input","createMediaStreamSource","onaudioprocess","e","left","inputBuffer","getChannelData","left16","send","JSON","stringify","connectionID","Array","catch","err","App","logo"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;;AAEA,OAAO,WAAP;AACA,OAAOC,MAAP,MAAmB,QAAnB;AACA,OAAOC,EAAP,MAAe,wBAAf;AACA,OAAOC,UAAP,MAAuB,kBAAvB;AACA,OAAOC,GAAP,MAAgB,mBAAhB,C,CAEA;AACA;;AAEA,MAAMC,UAAU,GAAGC,OAAO,CAAC,iCAAD,CAA1B,C,CAA+D;;;AAC/D,MAAMC,cAAc,GAAGD,OAAO,CAAC,yBAAD,CAA9B;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMG,YAAY,GAAGC,MAAM,CAACD,YAAP,IAAuBC,MAAM,CAACC,kBAAnD;AACA,MAAMC,OAAO,GAAG,IAAIH,YAAJ,EAAhB,C,CACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAII,MAAJ;AACA,IAAIC,SAAJ;AACA,IAAIC,eAAJ;AAEA,MAAMC,qBAAqB,GAAG,IAAIX,UAAU,CAACY,qBAAf,CAAqCV,cAAc,CAACW,MAApD,EAA4DX,cAAc,CAACY,QAA3E,CAA9B;AAEA,MAAMC,SAAS,GAAG,IAAIC,SAAJ,CAAc,qBAAd,CAAlB,C,CAAwD;;AACxDD,SAAS,CAACE,UAAV,GAAuB,aAAvB;;AAEAF,SAAS,CAACG,MAAV,GAAmB,MAAM;AACvBC,EAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACD,CAFD;;AAIAL,SAAS,CAACM,OAAV,GAAoB,MAAM;AACxBF,EAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACD,CAFD;;AAIAL,SAAS,CAACO,SAAV,GAAuBC,OAAD,IAAa;AACjCJ,EAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBG,OAAvB;AACD,CAFD;;AAIA,MAAMC,oBAAoB,GAAIC,MAAD,IAAY;AACvC;AACA,SAAO;AACHC,IAAAA,OAAO,EAAE;AACL,uBAAiB;AACbC,QAAAA,IAAI,EAAE,QADO;AAEbC,QAAAA,KAAK,EAAE;AAFM,OADZ;AAKL,qBAAe;AACXD,QAAAA,IAAI,EAAE,QADK;AAEXC,QAAAA,KAAK,EAAE;AAFI;AALV,KADN;AAWHC,IAAAA,IAAI,EAAEJ;AAXH,GAAP;AAaD,CAfD;;AAiBA,SAASK,2BAAT,CAAqCC,UAArC,EAAiD;AAC/C,MAAIC,GAAG,GAAGjC,GAAG,CAACkC,KAAJ,CAAUF,UAAV,CAAV;AACAZ,EAAAA,OAAO,CAACC,GAAR,CAAY,KAAZ,EAAmBY,GAAnB;AACA,MAAIA,GAAG,IAAI,IAAX,EACI,OAJ2C,CAM/C;;AACAb,EAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ,EAA+BV,eAA/B;AACA,MAAIwB,iBAAiB,GAAGpC,UAAU,CAACqC,gBAAX,CAA4BH,GAA5B,EAAiCtB,eAAjC,EAAkD,KAAlD,CAAxB;AACAS,EAAAA,OAAO,CAACC,GAAR,CAAY,aAAZ,EAA2Bc,iBAA3B;AACA,MAAIE,gBAAgB,GAAGtC,UAAU,CAACuC,SAAX,CAAqBH,iBAArB,CAAvB,CAV+C,CAY/C;;AACA,MAAII,iBAAiB,GAAGd,oBAAoB,CAACe,MAAM,CAACC,IAAP,CAAYJ,gBAAZ,CAAD,CAA5C,CAb+C,CAe/C;;AACA,MAAIK,MAAM,GAAG9B,qBAAqB,CAAC+B,QAAtB,CAA+BJ,iBAA/B,CAAb;AAEA,SAAOG,MAAP;AACD;;AAAA;;AAED,IAAIN,gBAAgB,GAAG,UAAUV,MAAV,EAAkBkB,UAAlB,EAA8BC,aAA9B,EAA6C;AACnE,MAAIA,aAAa,IAAID,UAArB,EAAiC;AAChC,WAAOlB,MAAP;AACA;;AACD,MAAImB,aAAa,GAAGD,UAApB,EAAgC;AAC/B,UAAM,6DAAN;AACA;;AACD,MAAIE,eAAe,GAAGF,UAAU,GAAGC,aAAnC;AACA,MAAIE,SAAS,GAAGC,IAAI,CAACC,KAAL,CAAWvB,MAAM,CAACwB,MAAP,GAAgBJ,eAA3B,CAAhB;AACA,MAAIK,MAAM,GAAG,IAAIC,UAAJ,CAAeL,SAAf,CAAb;AACA,MAAIM,YAAY,GAAG,CAAnB;AACA,MAAIC,YAAY,GAAG,CAAnB;;AACA,SAAOD,YAAY,GAAGF,MAAM,CAACD,MAA7B,EAAqC;AACpC,QAAIK,gBAAgB,GAAGP,IAAI,CAACC,KAAL,CAAW,CAACI,YAAY,GAAG,CAAhB,IAAqBP,eAAhC,CAAvB;AACA,QAAIU,KAAK,GAAG,CAAZ;AAAA,QAAeC,KAAK,GAAG,CAAvB;;AACA,SAAK,IAAIC,CAAC,GAAGJ,YAAb,EAA2BI,CAAC,GAAGH,gBAAJ,IAAwBG,CAAC,GAAGhC,MAAM,CAACwB,MAA9D,EAAsEQ,CAAC,EAAvE,EAA2E;AAC1EF,MAAAA,KAAK,IAAI9B,MAAM,CAACgC,CAAD,CAAf;AACAD,MAAAA,KAAK;AACL;;AAEDN,IAAAA,MAAM,CAACE,YAAD,CAAN,GAAuBL,IAAI,CAACW,GAAL,CAAS,CAAT,EAAYH,KAAK,GAAGC,KAApB,IAA6B,MAApD;AACAJ,IAAAA,YAAY;AACZC,IAAAA,YAAY,GAAGC,gBAAf;AACC;;AACD,SAAOJ,MAAP,CAxBkE,CAyBnE;AACA,CA1BD;;AA4BA,MAAMS,YAAY,GAAG,MAAM;AACzBC,EAAAA,SAAS,CAACC,YAAV,CAAuBC,YAAvB,CAAoC;AAClCC,IAAAA,KAAK,EAAE;AAD2B,GAApC,EAEGC,IAFH,CAESC,MAAD,IAAY;AAClB9C,IAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ,EAAyB6C,MAAzB;AAEA,QAAIC,SAAS,GAAG3D,OAAO,CAAC4D,qBAAR,CAA8B,IAA9B,EAAoC,CAApC,EAAuC,CAAvC,CAAhB;AACAD,IAAAA,SAAS,CAACE,OAAV,CAAkB7D,OAAO,CAAC8D,WAA1B;AACA9D,IAAAA,OAAO,CAAC+D,MAAR;AAEA,QAAIC,KAAK,GAAGhE,OAAO,CAACiE,uBAAR,CAAgCP,MAAhC,CAAZ;AACFM,IAAAA,KAAK,CAACH,OAAN,CAAcF,SAAd;;AAEAA,IAAAA,SAAS,CAACO,cAAV,GAA2B,UAAUC,CAAV,EAAa;AACvC,UAAIC,IAAI,GAAGD,CAAC,CAACE,WAAF,CAAcC,cAAd,CAA6B,CAA7B,CAAX,CADuC,CAEpC;;AACA,UAAIC,MAAM,GAAG3C,gBAAgB,CAACwC,IAAD,EAAO,KAAP,EAAc,KAAd,CAA7B;AACAxD,MAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ,EAAsB0D,MAAtB,EAJoC,CAMpC;;AAEA/D,MAAAA,SAAS,CAACgE,IAAV,CAAeC,IAAI,CAACC,SAAL,CAAe;AAACC,QAAAA,YAAY,EAAE,IAAf;AAAqBnB,QAAAA,KAAK,EAAEoB,KAAK,CAAC3C,IAAN,CAAWsC,MAAX;AAA5B,OAAf,CAAf,EARoC,CASpC;AACD,KAVH,CAVoB,CAwBlB;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA/D,IAAAA,SAAS,CAACM,OAAV,GAAoB,MAAM;AACxBF,MAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ;AACD,KAFD;;AAIAL,IAAAA,SAAS,CAACO,SAAV,GAAuBC,OAAD,IAAa;AACjCJ,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBG,OAAvB;AACD,KAFD;AAGD,GA3ED,EA4EC6D,KA5ED,CA4EQC,GAAD,IAAS;AACdlE,IAAAA,OAAO,CAACC,GAAR,CAAY,OAAZ,EAAqBiE,GAArB;AACD,GA9ED;AA+ED,CAhFD;;AAkFA,SAASC,GAAT,GAAe;AACb3B,EAAAA,YAAY;AACZ,sBACE;AAAK,IAAA,SAAS,EAAC,KAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAQ,IAAA,SAAS,EAAC,YAAlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAK,IAAA,GAAG,EAAE4B,IAAV;AAAgB,IAAA,SAAS,EAAC,UAA1B;AAAqC,IAAA,GAAG,EAAC,MAAzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,eAEE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,2BACO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBADP,yBAFF,eAKE;AACE,IAAA,SAAS,EAAC,UADZ;AAEE,IAAA,IAAI,EAAC,qBAFP;AAGE,IAAA,MAAM,EAAC,QAHT;AAIE,IAAA,GAAG,EAAC,qBAJN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBALF,CADF,CADF;AAkBD;;AAED,eAAeD,GAAf","sourcesContent":["import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport crypto from 'crypto';\nimport v4 from './lib/aws-signature-v4';\nimport audioUtils from './lib/audioUtils';\nimport mic from 'microphone-stream';\n\n// import marshaller from '@aws-sdk/eventstream-marshaller';\n// import util_utf8_node from '@aws-sdk/util-utf8-node';\n\nconst marshaller = require(\"@aws-sdk/eventstream-marshaller\"); // for converting binary event stream messages to and from JSON\nconst util_utf8_node = require(\"@aws-sdk/util-utf8-node\");\nconst BSON = require('bson');\n\nconst AudioContext = window.AudioContext || window.webkitAudioContext;\nconst context = new AudioContext();\n// const key = process.env.KEY;\n// const secret_key = process.env.SECRET_KEY;\n// const session_token = process.env.SESSION_TOKEN;\n// const region = process.env.REGION;\n// const language = process.env.LANGUAGE;\n// const sampleRate = process.env.SAMPLE_RATE;\n\nlet socket;\nlet micStream;\nlet inputSampleRate;\n\nconst eventStreamMarshaller = new marshaller.EventStreamMarshaller(util_utf8_node.toUtf8, util_utf8_node.fromUtf8);\n\nconst websocket = new WebSocket('ws://localhost:8000'); //put url\nwebsocket.binaryType = \"arraybuffer\";\n\nwebsocket.onopen = () => {\n  console.log(\"Connected\");\n};\n\nwebsocket.onerror = () => {\n  console.log(\"Error!!!!!!!!!\")\n}\n\nwebsocket.onmessage = (message) => {\n  console.log(\"MESSAGE\", message);\n};\n\nconst getAudioEventMessage = (buffer) => {\n  // wrap the audio data in a JSON envelope\n  return {\n      headers: {\n          ':message-type': {\n              type: 'string',\n              value: 'event'\n          },\n          ':event-type': {\n              type: 'string',\n              value: 'AudioEvent'\n          }\n      },\n      body: buffer\n  };\n};\n\nfunction convertAudioToBinaryMessage(audioChunk) {\n  let raw = mic.toRaw(audioChunk);\n  console.log(\"RAW\", raw);\n  if (raw == null)\n      return;\n\n  // downsample and convert the raw audio bytes to PCM\n  console.log(\"inputSamplerate\", inputSampleRate);\n  let downsampledBuffer = audioUtils.downsampleBuffer(raw, inputSampleRate, 16000);\n  console.log(\"downsampled\", downsampledBuffer);\n  let pcmEncodedBuffer = audioUtils.pcmEncode(downsampledBuffer);\n\n  // add the right JSON headers and structure to the message\n  let audioEventMessage = getAudioEventMessage(Buffer.from(pcmEncodedBuffer));\n\n  //convert the JSON object + headers into a binary event stream message\n  let binary = eventStreamMarshaller.marshall(audioEventMessage);\n\n  return binary;\n};\n\nvar downsampleBuffer = function (buffer, sampleRate, outSampleRate) {\n\tif (outSampleRate == sampleRate) {\n\t\treturn buffer;\n\t}\n\tif (outSampleRate > sampleRate) {\n\t\tthrow \"downsampling rate show be smaller than original sample rate\";\n\t}\n\tvar sampleRateRatio = sampleRate / outSampleRate;\n\tvar newLength = Math.round(buffer.length / sampleRateRatio);\n\tvar result = new Int16Array(newLength);\n\tvar offsetResult = 0;\n\tvar offsetBuffer = 0;\n\twhile (offsetResult < result.length) {\n\t\tvar nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n\t\tvar accum = 0, count = 0;\n\t\tfor (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n\t\t\taccum += buffer[i];\n\t\t\tcount++;\n\t\t}\n\n\t\tresult[offsetResult] = Math.min(1, accum / count) * 0x7FFF;\n\t\toffsetResult++;\n\t\toffsetBuffer = nextOffsetBuffer;\n  }\n  return result\n\t//return result.buffer;\n}\n\nconst handleListen = () => {\n  navigator.mediaDevices.getUserMedia({\n    audio: true,\n  }).then((stream) => {\n    console.log(\"STREAm!!!\", stream)\n\n    let processor = context.createScriptProcessor(2048, 1, 1);\n    processor.connect(context.destination);\n    context.resume();\n\n    let input = context.createMediaStreamSource(stream);\n\t\tinput.connect(processor);\n\n\t\tprocessor.onaudioprocess = function (e) {\n\t\t\tvar left = e.inputBuffer.getChannelData(0);\n      // var left16 = convertFloat32ToInt16(left); // old 32 to 16 function\n      var left16 = downsampleBuffer(left, 44100, 16000);\n      console.log(\"Buffer\", left16);\n\n      //websocket.send(left16);\n\n      websocket.send(JSON.stringify({connectionID: 3333, audio: Array.from(left16)}));\n      //websocket.send(BSON.serialize({connectionID: 3333, audio: left16}));\n    };\n    \n\n\n    // micStream = new mic();\n\n    // micStream.on(\"format\", function(data) {\n    //     inputSampleRate = data.sampleRate;\n    // });\n\n    // micStream.setStream(stream);\n\n    // // const websocket = new WebSocket('ws://localhost:8000'); //put url\n    // // websocket.binaryType = \"arraybuffer\";\n\n    // micStream.on('data', function(rawAudioChunk) {\n    //   // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n    //   console.log(\"DATA\", rawAudioChunk);\n    //   //let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //   let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //   console.log(\"Binary\", binary);\n    //   //websocket.emit('startGoogleCloudStream', '');\n    //   websocket.send(audioUtils.downsampleBuffer(rawAudioChunk, inputSampleRate, 16000));\n    //   //websocket.send(BSON.serialize({connectionID: 3333, audio: binary}));\n    //   //websocket.emit(\"binaryData\". BSON.serialize({connectionID: 3333, audio: binary}))\n    //   //websocket.send(binary);\n    //   // if (socket.readyState === socket.OPEN)\n    //   //     socket.send(binary);\n    // })    \n\n    // websocket.onopen = () => {\n    //   console.log(\"Connected\");\n    //   micStream.on('data', function(rawAudioChunk) {\n    //     // the audio stream is raw audio bytes. Transcribe expects PCM with additional metadata, encoded as binary\n    //     console.log(\"DATA\", rawAudioChunk);\n    //     //let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //     let binary = convertAudioToBinaryMessage(rawAudioChunk);\n    //     console.log(\"Binary\", binary);\n  \n    //     websocket.send(binary);\n    //     // if (socket.readyState === socket.OPEN)\n    //     //     socket.send(binary);\n    //   })    \n    // };\n\n\n    websocket.onerror = () => {\n      console.log(\"Error!!!!!!!!!\")\n    }\n    \n    websocket.onmessage = (message) => {\n      console.log(\"MESSAGE\", message);\n    };\n  })\n  .catch((err) => {\n    console.log(\"error\", err);\n  })\n};\n\nfunction App() {\n  handleListen();\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          Edit <code>src/App.js</code> and save to reload.\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n        </a>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}